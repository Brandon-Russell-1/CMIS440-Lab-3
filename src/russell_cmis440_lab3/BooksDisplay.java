package russell_cmis440_lab3;


/**
* Program Name: CMIS440 Lab 3 JavaDB Address Book Program
* @author Brandon R Russell
* @Course CMIS440
* Date: Dec 15,2010
*/


import java.util.List;
import javax.swing.JOptionPane;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.table.TableColumn;




/** This is the main window of operation for the books database. The purpose of
*  this class is to create a GUI Interface to the Book JavaDB Database
*  for the user to interact with.
*|----------------------------------------------------------------------------|
*|                                CRC: BooksDisplay                           |
*|----------------------------------------------------------------------------|
*|Creates GUI Interface                                                       |
*|Initialize Book object to hold current book to edit              Book       |
*|Initialize BooksQuery to handle Book data entries                BooksQuery |
*|----------------------------------------------------------------------------|
*
* @TheCs Cohesion - All methods in this class work together on similar task.
* Completeness - Completely creates/runs Person and PersonQueries object to
*                handle AddressBook entries.
* Convenience - There are sufficient methods and variables to complete the
*                required task.
* Clarity - The methods and variables are distinguishable and work in a
*           uniform manner to provide clarity to other programmers.
* Consistency - All names,parameters ,return values , and behaviors follow
*               the same basic rules.
*/
        
public class BooksDisplay extends javax.swing.JFrame {

   private Book currentEntry;
   private BooksQuery bookQueries;
   private List< Book > results;
   private int numberOfEntries = 0;
   private int currentEntryIndex;
   private String TempISBNHolder = "";
   private TextAreaLogger myTextAreaLogger = null;

    /**Constructor to initialize gui components and load database data.
    * @TheCs Cohesion - Constructor to initialize gui components and load
    *                   database data.
    * Completeness - Completely constructs gui components / loads database data.
    * Convenience - Simply constructs gui components / loads database data.
    * Clarity - It is simple to understand that this constructs gui components
    *           / loads database data.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    public BooksDisplay() {
        super( "Books" );
        initComponents();//Create GUI components
        /**
         * myTextAreaLogger will be used throughout to print any errors to the
         * TextArea component.
         * bookQueries is the main interface to the database
         * checkForErrors will see if the lastError variable is not null and
         * will print any errors if not.
         * loadDatabase will query the database for all entries to display in
         * the gui components.
         */
        myTextAreaLogger = new TextAreaLogger(debugTextArea);
        bookQueries = new BooksQuery();
        checkForErrors();
        loadDatabase();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        browsePanel = new javax.swing.JPanel();
        btnPrevious = new javax.swing.JButton();
        txtCurrentRecord = new javax.swing.JTextField();
        lblOf = new javax.swing.JLabel();
        txtTotalRecordCount = new javax.swing.JTextField();
        btnNext = new javax.swing.JButton();
        myJTableScrollPane = new javax.swing.JScrollPane();
        myJTable = new javax.swing.JTable();
        lblNoData = new javax.swing.JLabel();
        newUpdateDeletePanel = new javax.swing.JPanel();
        lblAuthorId = new javax.swing.JLabel();
        txtAuthorID = new javax.swing.JTextField();
        lblFirstName = new javax.swing.JLabel();
        txtFirstName = new javax.swing.JTextField();
        lblLastName = new javax.swing.JLabel();
        txtLastName = new javax.swing.JTextField();
        lblISBN = new javax.swing.JLabel();
        txtISBN = new javax.swing.JTextField();
        lblTitle = new javax.swing.JLabel();
        txtTitle = new javax.swing.JTextField();
        btnNewEntry = new javax.swing.JButton();
        btnUpdateEntry = new javax.swing.JButton();
        btnDeleteEntry = new javax.swing.JButton();
        lblEditionNumber = new javax.swing.JLabel();
        txtEditionNumber = new javax.swing.JTextField();
        lblCopyright = new javax.swing.JLabel();
        txtCopyright = new javax.swing.JTextField();
        findPanel = new javax.swing.JPanel();
        txtFind = new javax.swing.JTextField();
        btnFind = new javax.swing.JButton();
        errorPanel = new javax.swing.JPanel();
        myTextAreaScrollPane = new javax.swing.JScrollPane();
        debugTextArea = new javax.swing.JTextArea();
        btnClear = new javax.swing.JButton();
        myMenuBar = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        openAddressBookMenuItem = new javax.swing.JMenuItem();
        exitMenuItem = new javax.swing.JMenuItem();
        helpMenu = new javax.swing.JMenu();
        instructionsMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("CMIS440 Lab 3 JavaDB Book Database Program");
        setBackground(javax.swing.UIManager.getDefaults().getColor("Nb.Desktop.background"));

        browsePanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Browse"));

        btnPrevious.setText("Previous");
        btnPrevious.setToolTipText("Show previous record in editable area");
        btnPrevious.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnPreviousActionPerformed(evt);
            }
        });

        txtCurrentRecord.setToolTipText("Current record selected, or enter record to select");
        txtCurrentRecord.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtCurrentRecordActionPerformed(evt);
            }
        });

        lblOf.setText("of");

        txtTotalRecordCount.setBackground(javax.swing.UIManager.getDefaults().getColor("TextField.disabledBackground"));
        txtTotalRecordCount.setToolTipText("Total amount of records in database");
        txtTotalRecordCount.setEnabled(false);

        btnNext.setText("Next");
        btnNext.setToolTipText("Show next record in editable area");
        btnNext.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnNextActionPerformed(evt);
            }
        });

        myJTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        myJTable.setToolTipText("Show records in current database");
        myJTable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        myJTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                myJTableMouseClicked(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                myJTableMouseReleased(evt);
            }
        });
        myJTable.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                myJTablePropertyChange(evt);
            }
        });
        /**
        * The code below creates a ListSelectionModel based on the JTable and then
        * attaches a listener and refers it to the valueChanged method. This is used
        * so that the user can change the entry being edited by selecting it from the
        * table.
        */
        ListSelectionModel rowSM = myJTable.getSelectionModel();
        rowSM.addListSelectionListener(new ListSelectionListener() {
            public void valueChanged(ListSelectionEvent evt) {
                myJTableValueChanged(evt);
            }
        });
        myJTableScrollPane.setViewportView(myJTable);

        lblNoData.setForeground(javax.swing.UIManager.getDefaults().getColor("nb.errorForeground"));
        lblNoData.setText("*No Data Present");

        javax.swing.GroupLayout browsePanelLayout = new javax.swing.GroupLayout(browsePanel);
        browsePanel.setLayout(browsePanelLayout);
        browsePanelLayout.setHorizontalGroup(
            browsePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(browsePanelLayout.createSequentialGroup()
                .addGroup(browsePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, browsePanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(browsePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(myJTableScrollPane, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 689, Short.MAX_VALUE)
                            .addComponent(lblNoData)))
                    .addGroup(browsePanelLayout.createSequentialGroup()
                        .addGap(191, 191, 191)
                        .addComponent(btnPrevious)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(txtCurrentRecord, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lblOf)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtTotalRecordCount, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(btnNext)))
                .addContainerGap())
        );

        browsePanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {btnNext, btnPrevious});

        browsePanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {txtCurrentRecord, txtTotalRecordCount});

        browsePanelLayout.setVerticalGroup(
            browsePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(browsePanelLayout.createSequentialGroup()
                .addGroup(browsePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(txtCurrentRecord, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lblOf)
                    .addComponent(txtTotalRecordCount, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnNext)
                    .addComponent(btnPrevious))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(myJTableScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 249, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lblNoData))
        );

        newUpdateDeletePanel.setBorder(javax.swing.BorderFactory.createTitledBorder("New/Update/Delete Record"));

        lblAuthorId.setText("Author ID:");

        txtAuthorID.setBackground(javax.swing.UIManager.getDefaults().getColor("TextField.disabledBackground"));
        txtAuthorID.setToolTipText("Unique Key for Author");
        txtAuthorID.setEnabled(false);

        lblFirstName.setText("First Name:");

        txtFirstName.setToolTipText("Author First Name");

        lblLastName.setText("Last Name:");

        txtLastName.setToolTipText("Author Last Name");

        lblISBN.setText("ISBN:");

        txtISBN.setToolTipText("ISBN for book. Also unique key for book");

        lblTitle.setText("Title:");

        txtTitle.setToolTipText("Title of Book");

        btnNewEntry.setText("Insert New Entry");
        btnNewEntry.setToolTipText("Make new Author/Book Entry");
        btnNewEntry.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnNewEntryActionPerformed(evt);
            }
        });

        btnUpdateEntry.setText("Update Entry");
        btnUpdateEntry.setToolTipText("Update selected Author/Book record");
        btnUpdateEntry.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnUpdateEntryActionPerformed(evt);
            }
        });

        btnDeleteEntry.setText("Delete Entry");
        btnDeleteEntry.setToolTipText("Delete Author/Book record");
        btnDeleteEntry.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDeleteEntryActionPerformed(evt);
            }
        });

        lblEditionNumber.setText("Edition Number:");

        txtEditionNumber.setToolTipText("Edition Number of book");

        lblCopyright.setText("Copyright:");

        txtCopyright.setToolTipText("Copyright year of book");

        javax.swing.GroupLayout newUpdateDeletePanelLayout = new javax.swing.GroupLayout(newUpdateDeletePanel);
        newUpdateDeletePanel.setLayout(newUpdateDeletePanelLayout);
        newUpdateDeletePanelLayout.setHorizontalGroup(
            newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(newUpdateDeletePanelLayout.createSequentialGroup()
                .addGroup(newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(newUpdateDeletePanelLayout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(btnNewEntry)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnUpdateEntry)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnDeleteEntry))
                    .addGroup(newUpdateDeletePanelLayout.createSequentialGroup()
                        .addGap(43, 43, 43)
                        .addGroup(newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblTitle)
                            .addComponent(lblISBN, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblLastName, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblFirstName, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblAuthorId, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblEditionNumber)
                            .addComponent(lblCopyright))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(txtTitle, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtISBN, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtLastName, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtFirstName, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtEditionNumber, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtCopyright, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtAuthorID, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(10, Short.MAX_VALUE))
        );

        newUpdateDeletePanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {btnDeleteEntry, btnNewEntry, btnUpdateEntry});

        newUpdateDeletePanelLayout.setVerticalGroup(
            newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(newUpdateDeletePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(lblAuthorId)
                    .addComponent(txtAuthorID, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(lblFirstName)
                    .addComponent(txtFirstName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(lblLastName)
                    .addComponent(txtLastName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(lblISBN)
                    .addComponent(txtISBN, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(lblTitle)
                    .addComponent(txtTitle, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(lblEditionNumber)
                    .addComponent(txtEditionNumber, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(lblCopyright)
                    .addComponent(txtCopyright, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(27, 27, 27)
                .addGroup(newUpdateDeletePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnNewEntry)
                    .addComponent(btnUpdateEntry)
                    .addComponent(btnDeleteEntry))
                .addContainerGap(61, Short.MAX_VALUE))
        );

        findPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Find by Author Last Name"));

        txtFind.setToolTipText("Enter last name of author to find");

        btnFind.setText("Find");
        btnFind.setToolTipText("Find all records that match the last name entered");
        btnFind.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnFindActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout findPanelLayout = new javax.swing.GroupLayout(findPanel);
        findPanel.setLayout(findPanelLayout);
        findPanelLayout.setHorizontalGroup(
            findPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(findPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(txtFind, javax.swing.GroupLayout.DEFAULT_SIZE, 569, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnFind, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        findPanelLayout.setVerticalGroup(
            findPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(findPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(findPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtFind, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnFind))
                .addContainerGap(83, Short.MAX_VALUE))
        );

        errorPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Log"));

        debugTextArea.setColumns(20);
        debugTextArea.setRows(5);
        debugTextArea.setToolTipText("Display messages/errors/exceptions");
        myTextAreaScrollPane.setViewportView(debugTextArea);

        javax.swing.GroupLayout errorPanelLayout = new javax.swing.GroupLayout(errorPanel);
        errorPanel.setLayout(errorPanelLayout);
        errorPanelLayout.setHorizontalGroup(
            errorPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(myTextAreaScrollPane, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 385, Short.MAX_VALUE)
        );
        errorPanelLayout.setVerticalGroup(
            errorPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(myTextAreaScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 117, Short.MAX_VALUE)
        );

        btnClear.setText("Clear");
        btnClear.setToolTipText("Clear fields and reload database");
        btnClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnClearActionPerformed(evt);
            }
        });

        fileMenu.setText("File");
        fileMenu.setMaximumSize(new java.awt.Dimension(33, 32767));
        fileMenu.setPreferredSize(new java.awt.Dimension(33, 19));

        openAddressBookMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        openAddressBookMenuItem.setText("Switch to Address Book Database");
        openAddressBookMenuItem.setToolTipText("Close this Database and open the Address Book Database");
        openAddressBookMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openAddressBookMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(openAddressBookMenuItem);

        exitMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_X, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        exitMenuItem.setText("Exit");
        exitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(exitMenuItem);

        myMenuBar.add(fileMenu);

        helpMenu.setText("Help");

        instructionsMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_I, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        instructionsMenuItem.setText("Instructions");
        instructionsMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                instructionsMenuItemActionPerformed(evt);
            }
        });
        helpMenu.add(instructionsMenuItem);

        myMenuBar.add(helpMenu);

        setJMenuBar(myMenuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(errorPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(newUpdateDeletePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(browsePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(findPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addComponent(btnClear, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(browsePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(newUpdateDeletePanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(errorPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(findPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnClear)
                .addGap(11, 11, 11))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**Selects Previous entry from List of Book objects
    * @TheCs Cohesion - Selects Previous entry from List of Book objects
    * Completeness - Completely selects Previous entry from List of Book
    *                objects.
    * Convenience - Simply selects Previous entry from List of Book objects.
    * Clarity - It is simple to understand that this selects Previous entry
    *           from List of Book objects.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void btnPreviousActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnPreviousActionPerformed
        /**
         * Basically this deducts from the current entry index and if it is less
         * than 0 it makes it equal to the last record. This number is then
         * added to the current record text field and 
         * updateCurrentSelected record will use this number to determine 
         * which book object in the book object list to display for editing.
         */
        currentEntryIndex--;
        if ( currentEntryIndex < 0 ){
            currentEntryIndex = numberOfEntries - 1;
        }
        txtCurrentRecord.setText( "" + ( currentEntryIndex + 1 ) );
        updateCurrentSelectedRecord();
    }//GEN-LAST:event_btnPreviousActionPerformed

    /**Allows the user to enter a number of record to select
    * @TheCs Cohesion - Allows the user to enter a number of record to select
    * Completeness - Completely allows the user to enter a number of record to
    *                select.
    * Convenience - Simply allows the user to enter a number of record to
    *               select.
    * Clarity - It is simple to understand that this  allows the user to enter
    *           a number of record to select.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void txtCurrentRecordActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtCurrentRecordActionPerformed
        /**
         * updateCurrentSelectedRecord will use the number entered into the
         * current record textfield to determine which book object in the
         * book object list to display for editing.
         */
        updateCurrentSelectedRecord();
    }//GEN-LAST:event_txtCurrentRecordActionPerformed

    /**Selects Next entry from List of Book objects
    * @TheCs Cohesion - Selects Next entry from List of Book objects
    * Completeness - Completely selects Next entry from List of Book
    *                objects.
    * Convenience - Simply selects Next entry from List of Book objects.
    * Clarity - It is simple to understand that this selects Next entry
    *           from List of Book objects.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void btnNextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNextActionPerformed
        /**
        * Basically this adds 1 to the current entry index and if it is greater
        * than the total number of entries it makes it equal to the first record
        * . This number is then added to the current record text field and 
        * updateCurrentSelected record will use this number to determine 
        * which book object in the book object list to display for editing.
        */
        currentEntryIndex++;

        if ( currentEntryIndex >= numberOfEntries ){
          currentEntryIndex = 0;
        }
        txtCurrentRecord.setText( "" + ( currentEntryIndex + 1 ) );
        updateCurrentSelectedRecord();
    }//GEN-LAST:event_btnNextActionPerformed

    /** Find records based on author last name entered
    * @TheCs Cohesion - Find records based on author last name entered
    * Completeness - Completely finds records based on author last name entered.
    * Convenience - Simply finds records based on author last name entered.
    * Clarity - It is simple to understand that this finds records based on
    *           author last name entered.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void btnFindActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnFindActionPerformed
        /**
         * Run the .getBookByAuthorLastName method of bookQueries to return a
         * list of all books with the specified author last name. It then calls
         * checkForErrors to determine if any errors were thrown during this
         * method call by checking the lastError variable through the
         * getLastError method. If so it will send to the TextAreaLogger to
         * display in the TextArea on the GUI.
         * Next it will get the number of entries and if not equal to 0 it will
         * display the first one in the editable area. Also, it will reset the
         * model of the JTable to ensure it reflects the new data being shown
         * and also calls enableControls to make sure all the controls are
         * enabled. Else it will just load the entire database if there are 0
         * entries found.
         */
        results = bookQueries.getBookByAuthorLastName( txtFind.getText() );
        checkForErrors();
        numberOfEntries = results.size();

        if ( numberOfEntries != 0 ){
            currentEntryIndex = 0;//Show first entry in editable area
            currentEntry = results.get(currentEntryIndex);
            txtAuthorID.setText("" + currentEntry.getAuthorID());
            txtFirstName.setText(currentEntry.getAuthorFirstName());
            txtLastName.setText(currentEntry.getAuthorLastName());
            txtISBN.setText(currentEntry.getISBN());
            txtTitle.setText(currentEntry.getTitle());
            txtEditionNumber.setText(currentEntry.getEditionNumber());
            txtCopyright.setText(currentEntry.getCopyright());
            txtTotalRecordCount.setText("" + numberOfEntries);
            txtCurrentRecord.setText("" + (currentEntryIndex + 1));
            myJTable.setModel(bookQueries);//Update JTable
            setupTableColumns();
            enableControls();
        }
        else{
            loadDatabase();
        }
    }//GEN-LAST:event_btnFindActionPerformed

    /** Inputs a new entry into the database
    * @TheCs Cohesion - Inputs a new entry into the database
    * Completeness - Completely inputs a new entry into the database.
    * Convenience - Simply inputs a new entry into the database.
    * Clarity - It is simple to understand that this inputs a new entry into the
    *           database.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void btnNewEntryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNewEntryActionPerformed

        /**
         * This calls the addBook method of the bookQueries object to add
         * a new book to the database. It's assigned to a int to determine
         * if it was successful in adding the book or not. checkForErrors is
         * called after to see if any errors were thrown during the process.
         * After the book is added the database is reloaded to reflect the new
         * entry.
         */
        try{
            if (txtISBN.getText().equals("")){
                /**
                 * ISBN, unlike authorId, is generated by the user and not the
                 * computer. Since it is a primary key for the titles table
                 * it can't be blank. Well, technically yes it can, but it will
                 * cause issues later if allowed.
                 */
                myTextAreaLogger.log("ISBN must be populated before"
                        + " an insert ");
                return;
            }
            String ISBN = txtISBN.getText();
            String title = txtTitle.getText();
            int editionNumber = txtEditionNumber.getText().equals("") ? 0
                    : Integer.parseInt(txtEditionNumber.getText());
            String copyright = txtCopyright.getText();
            String firstName = txtFirstName.getText();
            String lastName = txtLastName.getText();

            int result = bookQueries.addBook(ISBN, title, editionNumber,
                    copyright, firstName, lastName);
            checkForErrors();

            myTextAreaLogger.log(result > 0 ? "Successful" : "Not Successful");

            loadDatabase();
        }catch (NumberFormatException exception){
            myTextAreaLogger.log(exception.toString());
        }catch (Exception exception){
            myTextAreaLogger.log(exception.toString());
        }
    }//GEN-LAST:event_btnNewEntryActionPerformed

    private void myJTablePropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_myJTablePropertyChange

    }//GEN-LAST:event_myJTablePropertyChange

    /** Deletes a entry into the database
    * @TheCs Cohesion - Deletes a entry into the database
    * Completeness - Completely deletes entry into the database.
    * Convenience - Simply deletes entry into the database.
    * Clarity - It is simple to understand that this deletes a entry into the
    *           database.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void btnDeleteEntryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDeleteEntryActionPerformed
        /**
         * If the authorID or ISBN fielda are blank then the method is
         * stopped since no entry is selected for deletion.
         * This calls the deleteBook method of the bookQueries object to
         * delete a book/author from the database. It's assigned to a int to
         * determine if it was successful in deleting the author/book or not.
         * checkForErrors is called after to see if any errors were thrown
         * during the process.
         * After the author/book are deleted the database is reloaded to
         * reflect the deleted entry is gone.
         */
        if (txtAuthorID.getText().equals("") || txtISBN.getText().equals("")){
            myTextAreaLogger.log("Author ID and ISBN must be "
                    + "populated before a delete ");
            return;
        }
        int result = bookQueries.deleteBook(
                Integer.parseInt(txtAuthorID.getText()), txtISBN.getText());
        checkForErrors();

        myTextAreaLogger.log(result > 0 ? "Successful" : "Not Successful");
        loadDatabase();
    }//GEN-LAST:event_btnDeleteEntryActionPerformed

    /** Updates a entry into the database
    * @TheCs Cohesion - Updates a entry into the database
    * Completeness - Completely updates a entry into the database.
    * Convenience - Simply updates a entry into the database.
    * Clarity - It is simple to understand that this updates a entry into the
    *           database.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void btnUpdateEntryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnUpdateEntryActionPerformed
        /**
         * If the authorID or ISBN fields are blank then the method is
         * stopped since no entry is selected for updating.
         * This calls the updateBook method of the bookQueries object to
         * update a book/author from the database. It's assigned to a int to
         * determine if it was successful in updating the author/book or not.
         * checkForErrors is called after to see if any errors were thrown
         * during the process.
         * After the author/book is updated the database is reloaded to
         * reflect the changes.
         */
        try{
            if (txtAuthorID.getText().equals("") ||
                    txtISBN.getText().equals("")){
                myTextAreaLogger.log("Author ID and ISBN must be "
                        + "populated before an update ");
                return;
            }
            int authorID = Integer.parseInt(txtAuthorID.getText());
            String ISBN = txtISBN.getText();
            String title = txtTitle.getText();
            int editionNumber = txtEditionNumber.getText().equals("") ? 0
                    : Integer.parseInt(txtEditionNumber.getText());
            String copyright = txtCopyright.getText();
            String firstName = txtFirstName.getText();
            String lastName = txtLastName.getText();

            int result = bookQueries.updateBook(ISBN, title, editionNumber,
                    copyright,firstName, lastName, authorID, TempISBNHolder );
            checkForErrors();

            myTextAreaLogger.log(result > 0 ? "Successful" : "Not Successful");
            loadDatabase();
        }catch (NumberFormatException exception){
            myTextAreaLogger.log(exception.toString());
        }catch (Exception exception){
            myTextAreaLogger.log(exception.toString());
        }
    }//GEN-LAST:event_btnUpdateEntryActionPerformed

    /** Properly exits the program.
    * @TheCs Cohesion - Properly exits the program.
    * Completeness - Completely exits the program.
    * Convenience - Simply exits the program.
    * Clarity - It is simple to understand that this exits the program.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void exitMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitMenuItemActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitMenuItemActionPerformed

    /** Shows instructions on using program.
    * @TheCs Cohesion - Shows instructions on using program.
    * Completeness - Completely shows instructions on using program.
    * Convenience - Simply shows instructions on using program.
    * Clarity - It is simple to understand that this shows instructions on using
    *           program.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void instructionsMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_instructionsMenuItemActionPerformed
        String instructionMessage = ""
                + "Add a Book/Author\n"
                + "1) Input Author First and Last Name, ISBN, Book Title, "
                + "Edition Number and Copyright year.\n "
                + "2) Click 'Insert New Entry'.\n"
                + "Update a Book/Author\n"
                + "1) Select the Book/Author you want to update by using the"
                + " Previous/Next buttons or by selecting them from the table"
                + ".\n"
                + "2) Update their information and click 'Update Entry\n"
                + "Delete a Book/Author\n"
                + "1) Select the Book/Author you want to delete by using the "
                + "Previous/Next buttons or by selecting them from the table.\n"
                + "2) Click 'Delete Entry'\n"
                + "Find a Author\n"
                + "1) Enter the authors last name into the text field in the"
                + " find area.\n"
                + "2) Click 'Find'.";

        JOptionPane.showMessageDialog(null, instructionMessage,
            "Instructions", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_instructionsMenuItemActionPerformed

    /** Switches over to AddressBook database
    * @TheCs Cohesion - Switches over to AddressBook database
    * Completeness - Completely switches over to AddressBook database.
    * Convenience - Simply switches over to AddressBook database.
    * Clarity - It is simple to understand that this switches over to 
    *           AddressBook database.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void openAddressBookMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openAddressBookMenuItemActionPerformed
        try{
            //Sets Look and Feel of GUI to Nimbus.
            UIManager.setLookAndFeel(
                    "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel");

        /**
         * After the UIManager is updated, then make a new Runnable on the
         * SwingUtilities.invoke later to run the program and make it visible.
         */
            java.awt.EventQueue.invokeLater(new Runnable() {
                public void run() {
                    new AddressBookDisplay().setVisible(true);
                }
            });

            this.dispose();//Dispose of this GUI since its no longer needed

        }catch (UnsupportedLookAndFeelException exception) {
            myTextAreaLogger.log(exception.getMessage());
        }catch (ClassNotFoundException exception) {
            myTextAreaLogger.log(exception.getMessage());
        }catch (InstantiationException exception) {
            myTextAreaLogger.log(exception.getMessage());
        }catch (IllegalAccessException exception) {
            myTextAreaLogger.log(exception.getMessage());
        }catch (Exception exception) {
            myTextAreaLogger.log(exception.getMessage());
        }
    }//GEN-LAST:event_openAddressBookMenuItemActionPerformed

    /** Clear find results, shows entire book database
    * @TheCs Cohesion - Clear find results, shows entire book database.
    * Completeness - Completely clears find results, shows entire book database.
    * Convenience - Simply clears find results, shows entire book database.
    * Clarity - It is simple to understand that this clears find results,
    *           shows entire book database.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void btnClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnClearActionPerformed
        txtFind.setText("");
        loadDatabase();
    }//GEN-LAST:event_btnClearActionPerformed

    private void myJTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_myJTableMouseClicked

    }//GEN-LAST:event_myJTableMouseClicked

    private void myJTableMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_myJTableMouseReleased

    }//GEN-LAST:event_myJTableMouseReleased


    /**Sets editable area to entry based on number found in txtCurrentRecord
    * @TheCs Cohesion - Sets editable area to entry based on number found in
    *                   txtCurrentRecord.
    * Completeness - Completely sets editable area to entry based on number
    *                found in txtCurrentRecord.
    * Convenience - Simply sets editable area to entry based on number found in
    *               txtCurrentRecord.
    * Clarity - It is simple to understand that this sets editable area to entry
    *           based on number found in txtCurrentRecord.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    * @exception NumberFormatException for Integer.parseInt
    * @exception Exception general exception capture
    */
    private void updateCurrentSelectedRecord(){
        try{
            /**
             * First it gets the number from the txtCurrentRecord and -1 since
             * the book/author list is zero based.
             */
            currentEntryIndex =
                    ( Integer.parseInt( txtCurrentRecord.getText() ) - 1 );

            /**
             * Only attempt to get the author/book if the number of entries
             * is not equal to 0 and the index entered is less than the
             * total number of entries. It assigns the currentEntry,
             * Book object, to the book object in the results list that is at
             * the selected index and then retrieves all the information and
             * displays in the editable area. Also, the record counters are
             * updated and the JTable is updated to be selected to the entry
             * in question.
             */
            if ( numberOfEntries != 0 && currentEntryIndex < numberOfEntries ){
                currentEntry = results.get( currentEntryIndex );
            txtAuthorID.setText("" + currentEntry.getAuthorID());
            txtFirstName.setText(currentEntry.getAuthorFirstName());
            txtLastName.setText(currentEntry.getAuthorLastName());
            txtISBN.setText(currentEntry.getISBN());
            TempISBNHolder = currentEntry.getISBN();
            txtTitle.setText(currentEntry.getTitle());
            txtEditionNumber.setText(currentEntry.getEditionNumber());
            txtCopyright.setText(currentEntry.getCopyright());
            txtTotalRecordCount.setText("" + numberOfEntries);
            txtCurrentRecord.setText("" + (currentEntryIndex + 1));
            myJTable.changeSelection(currentEntryIndex, 0, false, false);
            }
        }catch (NumberFormatException exception){
            myTextAreaLogger.log(exception.toString());
        }catch (Exception exception){
            myTextAreaLogger.log(exception.toString());
        }
    }

    /** Takes selected row from JTable to display in editable area
    * @TheCs Cohesion - Takes selected row from JTable to display in editable
    *                   area.
    * Completeness - Completely takes selected row from JTable to display in
    *                editable area.
    * Convenience - Simply takes selected row from JTable to display in editable
    *               area.
    * Clarity - It is simple to understand that this takes selected row from
    *           JTable to display in editable area.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void myJTableValueChanged(ListSelectionEvent evt) {
        if (evt.getValueIsAdjusting()){
            return; // if you don't want to handle intermediate selections
        }
        /**
         * This basically selection list model to the table change event and
         * retrieves the first selected index, or -1 if selection is empty
         * and updates the txtCurrentRecord w/ this index.
         * updateCurrentSelectedRecord will use this number to determine
         * which book object in the book object list to display for editing.
         */
        ListSelectionModel rowSM = (ListSelectionModel)evt.getSource();
        int selectedIndex = rowSM.getMinSelectionIndex();
        currentEntryIndex = selectedIndex;
        if (currentEntryIndex > -1){
            txtCurrentRecord.setText( "" + ( currentEntryIndex + 1 ) );
            updateCurrentSelectedRecord();
        }

    }

    /** Loads in data from database into results.
    * @TheCs Cohesion - Loads in data from database into results.
    * Completeness - Completely loads in data from database into results.
    * Convenience - Simply loads in data from database into results.
    * Clarity - It is simple to understand that this Loads in data from database
    *           into results.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    * @exception Exception general exception capture
    */
    private void loadDatabase(){
        try
        {
            /**
             * Calls the .getAllBooks to retrieve all records in the database.
             * checkForErrors will determine if any errors were thrown during
             * this process and if so will send them to the TextAreaLogger to
             * display in the TextArea on the GUI. Also, all of the fields in
             * the editable area are cleared and the JTable's model is reset to
             * reflect the new data being pulled in. Next, if the number of
             * entries pulled in is greater than zero the controls will be
             * enabled, otherwise they will be disabled until data is input.
             */
            results = bookQueries.getAllBooks();
            checkForErrors();
            numberOfEntries = results.size();
            txtAuthorID.setText("");
            txtFirstName.setText("");
            txtLastName.setText("");
            txtISBN.setText("");
            txtTitle.setText("");
            txtEditionNumber.setText("");
            txtCopyright.setText("");
            txtTotalRecordCount.setText( "" + numberOfEntries );
            txtCurrentRecord.setText("");
            myJTable.setModel(bookQueries);
            setupTableColumns();//Setup fixed widths for columns

            if ( numberOfEntries > 0 ){
                enableControls();
            }else{
                disableControls();
            }

        }
        catch ( Exception exception ){
            myTextAreaLogger.log(exception.toString());
        }
    }

    /** Enables the Controls
    * @TheCs Cohesion - Enables the Controls
    * Completeness - Completely enables the Controls.
    * Convenience - Simply enables the Controls.
    * Clarity - It is simple to understand that this enables the Controls.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void enableControls(){
         btnNext.setEnabled( true );
         btnPrevious.setEnabled( true );
         txtCurrentRecord.setEnabled(true);
         lblNoData.setVisible(false);
         btnDeleteEntry.setEnabled(true);
         btnUpdateEntry.setEnabled(true);
    }

    /** Disables the Controls
    * @TheCs Cohesion - Disables the Controls.
    * Completeness - Completely disables the Controls.
    * Convenience - Simply disables the Controls.
    * Clarity - It is simple to understand that this disables the Controls.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void disableControls(){
         btnNext.setEnabled( false );
         btnPrevious.setEnabled( false );
         txtCurrentRecord.setEnabled(false);
         lblNoData.setVisible(true);
         btnDeleteEntry.setEnabled(false);
         btnUpdateEntry.setEnabled(false);
    }

    /** Sets up fixed widths for table columns
    * @TheCs Cohesion - sets up fixed widths for table columns.
    * Completeness - Completely sets up fixed widths for table columns.
    * Convenience - Simply sets up fixed widths for table columns.
    * Clarity - It is simple to understand that this sets up fixed widths
    *           for table columns.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void setupTableColumns(){
        /**
         * I mainly have this to hide the authorId and duplicate ISBN columns,
         * but I figured if I'm gonna set a few columns I might as well set
         * all of them.
         */
        setColumnWidth(myJTable.getColumnModel().getColumn(0), 0);
        setColumnWidth(myJTable.getColumnModel().getColumn(1), 90);
        setColumnWidth(myJTable.getColumnModel().getColumn(2), 90);
        setColumnWidth(myJTable.getColumnModel().getColumn(3), 0);
        setColumnWidth(myJTable.getColumnModel().getColumn(4), 0);
        setColumnWidth(myJTable.getColumnModel().getColumn(5), 100);
        setColumnWidth(myJTable.getColumnModel().getColumn(6), 210);
        setColumnWidth(myJTable.getColumnModel().getColumn(7), 75);
        setColumnWidth(myJTable.getColumnModel().getColumn(8), 80);
    }

    /** Used injunction w/ setupTableColumns method to set column width
    * @TheCs Cohesion - Used injunction w/ setupTableColumns method to set
    *                   column width.
    * Completeness - Completely used injunction w/ setupTableColumns method
    *                to set column width.
    * Convenience - Simply used injunction w/ setupTableColumns method to set
    *               column width.
    * Clarity - It is simple to understand that this is used injunction w/
    *           setupTableColumns method to set column width.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void setColumnWidth(TableColumn column, int width){
        /**
         * Setup the preferred width of the columns. Again, this was mainly to
         * hide the unwanted columns by setting them to zero, but as of right
         * now I am using this for all columns for consistency.
         */
        column.setPreferredWidth(width);
    }


    /** Checks for errors from the bookQueries object
    * @TheCs Cohesion - Checks for errors from the bookQueries object
    * Completeness - Completely checks for errors from the bookQueries object.
    * Convenience - Simply checks for errors from the bookQueries object.
    * Clarity - It is simple to understand that this checks for errors from the
    *           bookQueries object.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void checkForErrors(){
        /**
         * Every time bookQueries method is called this is called right after
         * it. It calls the getLastError method to determine of the lastError
         * variable is null or not. If it is not null then an error occurred and
         * so this will send the error message to the TextAreaLogger to be
         * displayed on the TextArea on the GUI.
         */
        if (bookQueries.getLastError() != null){
            myTextAreaLogger.log(bookQueries.getLastError());
        }
    }
    




    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel browsePanel;
    private javax.swing.JButton btnClear;
    private javax.swing.JButton btnDeleteEntry;
    private javax.swing.JButton btnFind;
    private javax.swing.JButton btnNewEntry;
    private javax.swing.JButton btnNext;
    private javax.swing.JButton btnPrevious;
    private javax.swing.JButton btnUpdateEntry;
    private javax.swing.JTextArea debugTextArea;
    private javax.swing.JPanel errorPanel;
    private javax.swing.JMenuItem exitMenuItem;
    private javax.swing.JMenu fileMenu;
    private javax.swing.JPanel findPanel;
    private javax.swing.JMenu helpMenu;
    private javax.swing.JMenuItem instructionsMenuItem;
    private javax.swing.JLabel lblAuthorId;
    private javax.swing.JLabel lblCopyright;
    private javax.swing.JLabel lblEditionNumber;
    private javax.swing.JLabel lblFirstName;
    private javax.swing.JLabel lblISBN;
    private javax.swing.JLabel lblLastName;
    private javax.swing.JLabel lblNoData;
    private javax.swing.JLabel lblOf;
    private javax.swing.JLabel lblTitle;
    private javax.swing.JTable myJTable;
    private javax.swing.JScrollPane myJTableScrollPane;
    private javax.swing.JMenuBar myMenuBar;
    private javax.swing.JScrollPane myTextAreaScrollPane;
    private javax.swing.JPanel newUpdateDeletePanel;
    private javax.swing.JMenuItem openAddressBookMenuItem;
    private javax.swing.JTextField txtAuthorID;
    private javax.swing.JTextField txtCopyright;
    private javax.swing.JTextField txtCurrentRecord;
    private javax.swing.JTextField txtEditionNumber;
    private javax.swing.JTextField txtFind;
    private javax.swing.JTextField txtFirstName;
    private javax.swing.JTextField txtISBN;
    private javax.swing.JTextField txtLastName;
    private javax.swing.JTextField txtTitle;
    private javax.swing.JTextField txtTotalRecordCount;
    // End of variables declaration//GEN-END:variables

}
